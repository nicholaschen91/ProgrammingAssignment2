## Put comments here that give an overall description of what your
## functions do

  #Here we have 2 functions, makeCacheMatrix and cacheSolve. 
  #makeCacheMatrix takes a matrix and returns a list of 4 functions 
  #cacheSolve takes the list created by makeCacheMatrix and returns the cached inverse if it exists,
  #else it finds the inverse and stores it into the cache

## Write a short comment describing this function

  #makeCacheMatrix takes a matrix and returns a set of 4 functions, set(), get(), setInverse() and getInverse()
  #set() updates the matrix stored in the main function
  #get() retrieves the matrix stored by set()
  #setInverse() stores a matrix. This is called when makeCacheMatrix finds the inverse and stores it via setInverse()
  #getInverse() retrieves the matrix stored by setInverse()

makeCacheMatrix <- function(x = matrix()) {
  #set the original value of the inverse to NULL
  m <- NULL
  
  set <- function(y) {
    #This function is used when we want to store a new matrix, so it takes the input y 
    #and stores it as the matrix in the main function x
    x <<- y
    
    #Reset the inverse m because we are now working with a new matrix
    m <<- NULL
  }
  
  get <- function() {
    #Returns the matrix stored in the main function
    x
  }
  
  setInverse <- function(Inverse) {
    #Writes the input parameter Inverse into m
    m <<- Inverse
  }
  
  getInverse <- function() {
    #retrieves the stored inverse matrix m
    m
  }
  
  #creates a list of 4 functions that can be used by cacheSolve
  list(set = set, get = get,
       setInverse = setInverse,
       getInverse = getInverse)

}


## Write a short comment describing this function

#cacheSolve takes the list generated by the makeCacheMatrix function and does a few operations
#If there was a cached inverse, it is retrieved
#Else, cacheSolve computes the inverse and stores it via setInverse, which allows it to be retrieved in the future
cacheSolve <- function(x, ...) {
  
  #get the cached inverse and store in m
  m <- x$getInverse()
  
  #If there is actually a cached inverse, it is returned and this function ends
  if(!is.null(m)) {
    message("getting cached data")
    return(m)
  }
  
  #If there is no cached inverse, the matrix is first stored in the variable data
  data <- x$get()
  
  #Then, the matrix in data is inverted and stored into m
  m <- solve(data, ...)
  
  #This inverted matrix is then cached
  x$setInverse(m)
  
  #Finally the inverted matrix is returned to the user
  m
}
